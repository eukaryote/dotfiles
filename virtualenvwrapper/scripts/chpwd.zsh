# Source this during zsh initialization in order to get automatic
# activation/deactivation of a virtualenv when you cd in/out of a
# project directory that contains a '.venv' file containing the name
# of the virtualenv, assuming you have virtualenvwrapper installed
# and configured.
#
# For example, if you have a virtualenv named 'py3sandbox', then adding
# 'py3sandbox' to the .venv file of some python project directory results
# in 'workon py3sandbox' being called to activate the virtualenv when
# you cd into that directory and 'deactivate' being called to deactivate
# the virtualenv when you cd to a different directory that isn't inside
# the project directory.
#
# This doesn't support activating when you cd directly into a descendant
# of the dir with the '.venv' file without going into the project dir that
# contains the '.venv' file first.


# full path to the virtualenv directory;
# set in 'chpwd' and cleared in 'chpwd_check_deactivation'
_chpwd_venv_dir=""

# non-empty if currently handling a chpwd call, and used to distinguish
# between a user-generated chdir and a chdir that is generated by this
# script when it calls 'workon'; set and cleared in 'chpwd'
_chpwd_activating=""


# Deactivate the current virtualenv if necessary
chpwd_check_deactivation() {
    # do nothing if not in a virtualenv or not in one that we activated
    if [[ -z "${VIRTUAL_ENV}" || -z "${_chpwd_venv_dir}" || -z "${CHPWD_WORKON}" ]]; then
        return 0
    fi
    # do nothing if current directory is a descendant of the virtualenv dir
    if [[ ("$(pwd)" =~ "${_chpwd_venv_dir}(\$|/)" ) ]]; then
        return 0
    fi

    _chpwd_venv_dir=""
    unset CHPWD_WORKON
    deactivate
}

chpwd() {
    emulate -L zsh

    # return immediately if currently activating;
    # this no longer returns immediately if OLDPWD is the same as PWD
    # because when a new shell launches with the current directory being a
    # .venv directory, it's nice to allow simply 'cd .' to activate the
    # virtualenv, rather than requiring two cd commands to exit the directory
    # and then re-enter it.
    if [[ -n "${_chpwd_activating}" ]]; then
        return 0
    fi

    _chpwd_activating=1
    #echo "chpwd.zsh: ${OLDPWD} -> ${PWD}"

    chpwd_check_deactivation

    if [[ ! -s .venv ]]
    then
        _chpwd_activating=""
        return 0
    fi

    local venv="$(cat .venv 2> /dev/null)"
    if [[ -n "${venv}" && -d "${WORKON_HOME}/${venv}" ]]; then
        # activate if the .venv contents give a name different than the
        # name of the directory of the currently activated virtualenv, if any
        if [[ "${venv}" !=  "${VIRTUAL_ENV##*/}" ]]; then
        # if [[ "${venv}" !=  "${CHPWD_WORKON}" ]]; then
            # record that workon was invoked by this script, so that we can
            # not deactivate when 'workon' was set up from the shell explicitly
            export CHPWD_WORKON="${venv}"
            #echo "chpwd.zh: workon ${venv}"
            workon "${venv}"
        fi
        # still need to set the venv dir even if the venv was already
        # activated, because it might have been activated by virtualenvwrapper
        # when creating the virtualenv rather than via this script, but we
        # wouldn't yet have set the variable, so wouldn't be able to
        # deactivate later.
        _chpwd_venv_dir="$(pwd)"
    fi
    _chpwd_activating=""
}
